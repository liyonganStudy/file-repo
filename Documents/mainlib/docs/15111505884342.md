# 理解apk安装流程

## 理解AndroidManifest
AndroidManifest.xml文件会在apk安装过程中被解析成相关info类。
![屏幕快照 2017-11-20 下午12.05.38](media/15111505884342/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-20%20%E4%B8%8B%E5%8D%8812.05.38.png)
### PackageInfo类简介
该类包含了从AndroidManifest.xml文件中收集的所有信息。
通过源码我们知道PackageInfo是实现Parcelable接口，所以它可以在进程间传递
### PackageItemInfo类简介
它是AndroidManifest.xml文件中所有节点的基类，代表一个应用包内所有组件和通用信息的基类。该类提供最基本的属性集合，如：label、icon、meta等。一般不会直接用这个类，设计它的目的就是为包内其他基本组件提供统一的基础定义。
### ApplicationInfo类简介
ApplicationInfo类：它继承自PackageItemInfo并实现了Parcelable 接口，它对应manifest里面的<application>节点的信息
### ComponentInfo类简介
ComponentInfo，它代表一个应用内部的组件(如ActivityInfo、ServiceInfo、ProviderInfo)，一般不会直接使用这个类，它被设计出来是为了不同应用的组件共享统一的定义。它继承与PackageItemInfo，但它不像ApplicationInfo一样实现了Parcelable接口。
### ActivityInfo类简介
它继承自ComponentInfo并实现了Parcelable 接口，它对应manifest里面的<activity>或者<receiver>节点的信息。我们可以通过它来设置我们的任何属性，包括theme、launchMode等，常用方法继承至PackageItemInfo类中的loadIcon()和loadLabel()

![屏幕快照 2017-11-20 下午12.13.59](media/15111505884342/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-20%20%E4%B8%8B%E5%8D%8812.13.59.png)

## 理解PackageManager
* PackageManager是一个抽象类，它的具体子类是ApplicationPackageManager。
* ApplicationPackageManager的重要方法都是调用的内部成员变量mPM(IPackageManager)中对应的方法。


```java
@Override
    public PackageManager getPackageManager() {
        // 第一步
        if (mPackageManager != null) {
            return mPackageManager;
        }
        // 第二步
        IPackageManager pm = ActivityThread.getPackageManager();
         // 第三步
        if (pm != null) {
            // Doesn't matter if we make more than one instance.
            return (mPackageManager = new ApplicationPackageManager(this, pm));
        }
        return null;
    }
```
### IPackageManager类
![屏幕快照 2017-11-20 下午3.23.06](media/15111505884342/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-20%20%E4%B8%8B%E5%8D%883.23.06.png)

* **IPackageManager负责通信**。IPackageManager接口类中定义了很多业务方法，但是由于安全等方面的考虑，Android对外(即SDK)提供的仅仅是一个子集，该子集被封装在抽象类PackageManager中。客户端一般通过Context的getPackageManager函数返回一个类型为PackageManager的对象，该对象的实际类型是PackageManager的子类ApplicationPackageManager。ApplicationPackageManager并没有直接参与Binder通信，而是通过mPM成员变量指向了一个IPackageManager.Stub.Proxy类型的对象
* **AIDL中的Binder服务端**是PackageManagerService，因为PackageManagerService继承自IPackageManager.Stub。由于IPackageManager.Stub类从Binder派生，所以PackageManagerService将作为服务端参与Binder通信。
* **AIDL中的Binder客户端**是ApplicationPackageManager中成员变量mPM，因为mPM内部指向的是IPackageManager.Stub.Proxy

![屏幕快照 2017-11-20 下午3.28.32](media/15111505884342/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-20%20%E4%B8%8B%E5%8D%883.28.32.png)

![屏幕快照 2017-11-20 下午3.34.25](media/15111505884342/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-20%20%E4%B8%8B%E5%8D%883.34.25.png)

### PackageManagerService类
PackageManagerService继承自IPackageManager.Stub，Stub类从Binder派生，因此PackageManagerService将作为服务端参与Binder通信。
#### PackageParser
这个类主要用于解析APK，解析其AndroidManifest.xml文件得到package的所有信息。补充一下：PackageParser.Package这个类用于容纳解析出的信息。

## 参考资料
[APK安装流程详解1——有关"安装ing"的实体类概述](http://cdn2.jianshu.io/p/71c1ce538ee8)


