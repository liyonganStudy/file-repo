# 理解classloader
## classloader是什么？
* ClassLoader是类加载器，它是用来形容将一个类的二进制流加载到虚拟机中的过程
* 一个类的唯一性要由它的类加载器和它本身来确定，也就是说一个Class文件如果使用不同的类加载器来加载，那么加载出来的类也是不相等的
* Java中为了保证一个类的唯一性使用了双亲委派模型，也就是说如果要加载一个类首先会委托给自己的父加载器去完成，父加载器会再向上委托，直到最顶层的类加载器，如果父加载器没有找个要加载的类，子类才会尝试自己去加载，这样就保证了加载的类都是一个类

## Android中的ClassLoader
### BootClassLoader
它是Android中最顶层的ClassLoader，创建一个ClassLoader需要传入一个parent，而android中所有的ClassLoader的最终parent都是BootClassLoader
它是ClassLoader的内部类,可以通过ClassLoader.getSystemClassLoader().getParent()得到
### PathClassLoader
继承自BaseDexClassLoader ，它是我们apk的默认加载器，它是用来加载系统类和主dex文件中的类的，但是系统类是由BootClassLoader加载的，如果apk中有多个dex文件，只会加载主dex
### DexClassLoader
继承自BaseDexClassLoader ，可以用来加载外置的dex文件或者apk等 

### 总结
Android中主要使用的ClassLoader有PathClassLoader和DexClassLoader，它们都继承自BaseDexClassLoader，BaseDexClassLoader中维护了一个DexPathList，PathClassLoader和DexClassLoader查找类的操作直接调用BaseClassLoader的findClass方法，而BaseClassLoader的findClass中又通过内部维护的DexPathList来查找，DexPathList中又维护这一个Element数组，这个数组中Element元素其实就是Dex文件。

PathClassLoader和DexClassLoader最大的区别就是DexClassLoader可以加载外置dex文件，这是因为PathClassLoader构造方法中像上传递时第二个参数传了null，这个参数代表的是dex优化后的路径，DexPathList在生成Element数组时会判断这个参数是否为null，如果为null就使用系统默认路径/data/dalvik-cache，这也是导致如果要加载外置dex文件只能使用DexClassLoader的原因。

PathClassLoader只会加载apk中的主dex文件，其他的dex文件是使用DexClassloader动态加载进来，然后通过反射获取到PathClassLoader中的DexPathList，然后再拿到DexPathList中的Element数组，最后将后加载进来的dex和反射拿到的数组进行合并后并重新设置回去，这也是Google的MultiDex的做法，在我之前写过的插件化的实现的博客中也采用了这种方式

## 应用启动过程
1. 每个应用程序首先会创建一个属于自己的进程，在进程创建后会调用ActivityThread中的mian方法
2. 在mian方法中会开启消息循环并和AMS绑定，然后AMS会调用ActivityThread中的bindApplication方法
3. 这个方法发送了一个消息到Handler中并调用handleBindApplication方法开始创建Application

### 创建LoadedApk
```java
// frameworks/base/core/java/android/app/ActivityThread.java
private void handleBindApplication(AppBindData data) {
    //创建LoaderApk
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    //调用了LoadedApk中的makeApplication方法创建Application
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);
}

public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
        CompatibilityInfo compatInfo) {
    //注意这里传入的null
    return getPackageInfo(ai, compatInfo, null, false, true, false);       
}

//上面传入的第3个参数是null，也就是说这里的ClassLoader是null
private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
        boolean registerPackage) {
    //直接创建一个LoadedApk,传入了ClassLoader，但是上面传入的是null
    packageInfo = new LoadedApk(this, aInfo, compatInfo, baseLoader,
                        securityViolation, includeCode &&
                        (aInfo.flags&ApplicationInfo.FLAG_HAS_CODE) != ,
                         registerPackage);       
}
```

```java
// frameworks/base/core/java/android/app/LoadedApk.java 
    public LoadedApk(ActivityThread activityThread, ApplicationInfo aInfo,
        CompatibilityInfo compatInfo, ClassLoader baseLoader,
        boolean securityViolation, boolean includeCode, boolean registerPackage) {

    mActivityThread = activityThread;
    setApplicationInfo(aInfo);
    mPackageName = aInfo.packageName;
    //将传入的ClassLoader赋值给了mBaseClassLoader
    mBaseClassLoader = baseLoader;
    mSecurityViolation = securityViolation;
    mIncludeCode = includeCode;
    mRegisterPackage = registerPackage;
    mDisplayAdjustments.setCompatibilityInfo(compatInfo);
}
```
### 创建Application
```java
// frameworks/base/core/java/android/app/LoadedApk.java
public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) {
     //获取ClassLoader
    java.lang.ClassLoader cl = getClassLoader();   
    //不是系统应用执行了 initializeJavaContextClassLoader     
    initializeJavaContextClassLoader();
    //创建Context，这个就是hook时获取的BaseContext
    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
    //创建Application
    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);
    appContext.setOuterContext(app);
}

public ClassLoader getClassLoader() {
    //获取ClassLoader对象，这里传入的mBaseClassLoader还是null,因为LoadedApk创建的时候传入的就是null
    mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib, mBaseClassLoader);
    // 这个mClassLoader就是LoadedApk中对应的classloader
}

private void initializeJavaContextClassLoader() {
    ClassLoader contextClassLoader =
        (sharable)
        ? new WarningContextClassLoader()
        : mClassLoader;                
    Thread.currentThread().setContextClassLoader(contextClassLoader);   
}
```
LoadedApk中的classloader被赋值为下面的PathClassloader。

```java
// frameworks/base/core/java/android/app/ApplicationLoaders.java
public ClassLoader getClassLoader(String zip, String libPath, ClassLoader parent) {
    //这里获取的是BootClassLoader,文章开头说过这个方法
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();
            //parent是LoadedApk刚传入的mBaseClassLoader，还是null
        if (parent == null) {
            //设置parent=BootClassLoader
            parent = baseParent;
        }
    //创建PathClassLoader,终于出现了
    PathClassLoader pathClassloader = new PathClassLoader(zip, libPath, parent);
    return pathClassloader;
}
```
最开始创建LoadedApk时传入的ClassLoader为null，在创建Application时，通过ApplicationLoaders创建了PathClassLoader,PathClassLoader的parent是BootClassLoader。

```java
// frameworks/base/core/java/android/app/ContextImpl.java 
static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) {
    if (packageInfo == null) throw new IllegalArgumentException("packageInfo");
    //直接new了一个ContextImpl
    return new ContextImpl(null, mainThread,
            packageInfo, null, null, false, null, null);
}

private ContextImpl(ContextImpl container, ActivityThread mainThread,
        LoadedApk packageInfo, IBinder activityToken, UserHandle user, boolean restricted,
        Display display, Configuration overrideConfiguration) {
    //mPackageInfo，将传入的LoadedApk赋值给了mPackageInfo，这就是在Hook代码中反射获取的mPackageInfo
    mPackageInfo = packageInfo;
} 
```
Application中的ComtextImpl中有LoadedApk对象。

```java
// frameworks/base/core/java/android/app/Instrumentation.java 
public Application newApplication(ClassLoader cl, String className, Context context)
        throws InstantiationException, IllegalAccessException, 
        ClassNotFoundException {

    //使用了ClassLoader.loadClass来加载Application类,这个ClassLoader就是上面创建的PathClassLoader,这里传入的context就是上面创建的ContextImpl    
    return newApplication(cl.loadClass(className), context);
}

static public Application newApplication(Class<?> clazz, Context context)
        throws InstantiationException, IllegalAccessException, 
        ClassNotFoundException {
    //创建Application并回调  attach方法
    Application app = (Application)clazz.newInstance();
    //调用Application的attach方法,传入的context还是上面创建的ContextImpl   
    app.attach(context);
    return app;
}
```

```java
// frameworks/base/core/java/android/app/Application.java 
final void attach(Context context) {
    //调用了ContextWrapper的方法，看到这个方法了吧，上面提到过，够早回调的吧，context还是ContextImpl
    attachBaseContext(context);
    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;
}
```
1.Applicaiont
## 参考资料
[插件化和classloader](http://blog.csdn.net/yulong0809/article/details/78426280)


