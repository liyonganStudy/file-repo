# VirtualApk分析
[TOC]

VirtualApk的实现和代码逻辑比较清晰，由于插件Activity是没有在宿主Manifest中注册，所以先使用提前注册的坑位Activity替换插件中Activity骗过AMS的检查，然后hook系统行为启动插件中Activity，最后在插件中使用插件自己的Resouce，Context。
我们可以跟着流程走一遍可以理解的它的实现。
主要关注以下三个方面：

* 如何管理和使用坑位Activity？
* 如何hook系统启动插件Activity？
* 如何使用插件中相关资源和信息？

![屏幕快照 2017-12-01 下午5.20.39-w240](media/15120360813537/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-01%20%E4%B8%8B%E5%8D%885.20.39.png)   


## PluginManager初始化
首先在Application的创建时调用PluginManager的init（）方法。

* 这里PluginManager.getInstance(base)应该改为PluginManager.getInstance（），因为只有第一次时会将宿主的context传给PluginManager，同时这个context最好是ApplicationContext。
* init方法不必在Applicaiont.attachBaseContext中调用，只要在加载插件前调用即可。

```java
@Override
protected void attachBaseContext(Context base) {
    super.attachBaseContext(base);
    long start = System.currentTimeMillis();                            
    PluginManager.getInstance(base).init();
    Log.d("ryg", "use time:" + (System.currentTimeMillis() - start));
}

public static PluginManager getInstance(Context base) {
    if (sInstance == null) {
        synchronized (PluginManager.class) {
            if (sInstance == null)
                sInstance = new PluginManager(base);
            }
        }
    return sInstance;
}

    private PluginManager(Context context) {
        Context app = context.getApplicationContext();
        if (app == null) {
            this.mContext = context;
        } else {
            this.mContext = ((Application)app).getBaseContext();
        }
        prepare();
    }
```
```java
public void init() {
    mComponentsHandler = new ComponentsHandler(this);
}
```
prepare方法我们一会再看，我们先看看init方法。
init方法也很简单，创建了ComponentsHandler对象，这个ComponentsHandler其实就是Activity，service等坑位管理者（后面讲解只针对Activity）。
### 坑位管理者ComponentsHandler
在CoreLibrary的AndroidManifest中声明了一系列坑位Activity。
![屏幕快照 2017-12-01 下午5.26.29](media/15120360813537/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-01%20%E4%B8%8B%E5%8D%885.26.29.png)

```java
public class ComponentsHandler {

    public static final String TAG = "PluginManager";

    private Context mContext;
    private PluginManager mPluginManager;
    private StubActivityInfo mStubActivityInfo = new StubActivityInfo();
```
其中StubActivityInfo对应着上面的坑位Activity。主要是根据启动模式和主题的不同，将要启动的目标Activity映射到坑位Activity，并将这种对应关系保存下来。只有一个核心方法，逻辑也很清楚。

```java
public String getStubActivity(String className, int launchMode, Theme theme) {
        String stubActivity= mCachedStubActivity.get(className);
        if (stubActivity != null) {
            return stubActivity;
        }

        TypedArray array = theme.obtainStyledAttributes(new int[]{
                android.R.attr.windowIsTranslucent,
                android.R.attr.windowBackground
        });
        boolean windowIsTranslucent = array.getBoolean(0, false);
        array.recycle();
        if (Constants.DEBUG) {
            Log.d("StubActivityInfo", "getStubActivity, is transparent theme ? " + windowIsTranslucent);
        }
        stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity);
        switch (launchMode) {
            case ActivityInfo.LAUNCH_MULTIPLE: {
                stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity);
                if (windowIsTranslucent) {
                    stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, 2);
                }
                break;
            }
            case ActivityInfo.LAUNCH_SINGLE_TOP: {
                usedSingleTopStubActivity = usedSingleTopStubActivity % MAX_COUNT_SINGLETOP + 1;
                stubActivity = String.format(STUB_ACTIVITY_SINGLETOP, corePackage, usedSingleTopStubActivity);
                break;
            }
            case ActivityInfo.LAUNCH_SINGLE_TASK: {
                usedSingleTaskStubActivity = usedSingleTaskStubActivity % MAX_COUNT_SINGLETASK + 1;
                stubActivity = String.format(STUB_ACTIVITY_SINGLETASK, corePackage, usedSingleTaskStubActivity);
                break;
            }
            case ActivityInfo.LAUNCH_SINGLE_INSTANCE: {
                usedSingleInstanceStubActivity = usedSingleInstanceStubActivity % MAX_COUNT_SINGLEINSTANCE + 1;
                stubActivity = String.format(STUB_ACTIVITY_SINGLEINSTANCE, corePackage, usedSingleInstanceStubActivity);
                break;
            }

            default:break;
        }

        mCachedStubActivity.put(className, stubActivity);
        return stubActivity;
    }
```
当我们启动一个插件中的Activity时，会自动将其替换为坑位Activity以达到欺骗AMS的作用。

```java
public void markIntentIfNeeded(Intent intent) {
    String targetPackageName = intent.getComponent().getPackageName();
    String targetClassName = intent.getComponent().getClassName()
    // search map and return specific launchmode stub activity
    if (!targetPackageName.equals(mContext.getPackageName()) && mPluginManager.getLoadedPlugin(targetPackageName) != null) {
        intent.putExtra(Constants.KEY_IS_PLUGIN, true)
        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);
        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);
        dispatchStubActivity(intent);
    }

    private void dispatchStubActivity(Intent intent) {
        ComponentName component = intent.getComponent();
        String targetClassName = intent.getComponent().getClassName();
        LoadedPlugin loadedPlugin = mPluginManager.getLoadedPlugin(intent);
        ActivityInfo info = loadedPlugin.getActivityInfo(component);
        if (info == null) {
            throw new RuntimeException("can not find " + component);
        }
        int launchMode = info.launchMode;
        Resources.Theme themeObj = loadedPlugin.getResources().newTheme();
        themeObj.applyStyle(info.theme, true);
        String stubActivity = mStubActivityInfo.getStubActivity(targetClassName, launchMode, themeObj);
        Log.i(TAG, String.format("dispatchStubActivity,[%s -> %s]", targetClassName, stubActivity));
        intent.setClassName(mContext, stubActivity);
    }
```
### 初始化prepare()
现在我们再看看prepare方法到底做了什么，这个方法主要是hook了系统的Instrumentation行为，我们知道Activity的创建和声明周期都依赖它，利用Hook修改其行为加上坑位Activity，我们可以打开没有在Manifest中申明的Activity，也就是插件中的Activity。

```java
private void prepare() {
    Systems.sHostContext = getHostContext();
    this.hookInstrumentationAndHandler();
}
```

## hook系统行为加载没注册Activity
插件中的Activity都是没有宿主的Manifest中注册过的，直接启动会报错。跟踪startActivity的调用流程，会发现最终进入Instrumentation的execStartActivity方法，然后再通过ActivityManagerProxy与AMS进行交互，而Activity是否存在的校验是发生在AMS端，所以我们可以提前将Activity的ComponentName替换成占坑的名字就可以解决上面的问题。

使用上面的方案解决了AMS校验问题，但这样启动的就是占坑的Activity而不是插件中的Activity，所以我们还得在合适的时机修改成启动插件中的Activity。

AMS在处理完启动Activity后，会调用：app.thread.scheduleLaunchActivity，即调用ApplicationThread.scheduleLaunchActivity方法，在其内部会调用mH类的sendMessage方法，传递的标识为H.LAUNCH_ACTIVITY，进入调用到ActivityThread的handleLaunchActivity方法，进入调用mInstrumentation.newActivity()。

所以我们还应该在newActivity中替换启动插件中实际需要启动的Activity。不过此时使用的Resource，Context等还是使用的宿主，也需要在合适时机替换掉，可以在Instrumentation的callActivityOnCreate中替换。

hook Instrumentation方案大同小异，我们可以看看具体实现。

* 首先获取ActivityThread，ActivityThread中有个静态成员变量sCurrentActivityThread，我们可以直接通过反射获取。

```java
@UiThread
public static Object getActivityThread(Context base) {
    if (sActivityThread == null) {
        try {
            Class<?> activityThreadClazz = 
            Class.forName("android.app.ActivityThread");
            Object activityThread = null;
            try {
                activityThread = ReflectUtil.getField(activityThreadClazz, 
                null, "sCurrentActivityThread");
            } catch (Exception e) {
                    // ignored
            }
            if (activityThread == null) {
                activityThread = ((ThreadLocal<?>) 
                ReflectUtil.getField(activityThreadClazz, null, "sThreadLocal")).get();
            }
            sActivityThread = activityThread;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    return sActivityThread;
}   
```
* 在调用ActivityThread的getInstrumentation得到Instrumentation

```java
    public static Instrumentation getInstrumentation(Context base) {
        if (getActivityThread(base) != null) {
            try {
                sInstrumentation = (Instrumentation) ReflectUtil.invoke(
                        sActivityThread.getClass(), sActivityThread, "getInstrumentation");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return sInstrumentation;
    }
```
* 创建我们自己的Instrumentation并hook掉系统的Instrumentation。

```java
final VAInstrumentation instrumentation = new VAInstrumentation(this, baseInstrumentation);
Object activityThread = ReflectUtil.getActivityThread(this.mContext)
ReflectUtil.setInstrumentation(activityThread, instrumentation);

    public static void setInstrumentation(Object activityThread, Instrumentation instrumentation) {
        try {
            ReflectUtil.setField(activityThread.getClass(), activityThread, "mInstrumentation", instrumentation);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```
在上面的自定Instrumentation的execStartActivity，newActivity，callActivityOnCreate等方法中可以执行我们上面说的替换和还远以及替换资源和context等操作。

### 自定义Instrumentation行为
* 使用上面提到mPluginManager.getComponentsHandler().markIntentIfNeeded(intent)方法获取坑位Activity的Intent并启动坑位Activity。

```java
    public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
        mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);
        // null component is an implicitly intent
        if (intent.getComponent() != null) {
            // resolve intent with Stub Activity if needed
            this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);
        }
        ActivityResult result = realExecStartActivity(who, contextThread, token, target,
                    intent, requestCode, options);
        return result;
    }
```
* 启动插件中实际要打开的Activity

```java
    public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        try {
            cl.loadClass(className);
        } catch (ClassNotFoundException e) {
            LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);
            String targetClassName = PluginUtil.getTargetActivity(intent);
            if (targetClassName != null) {
                Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);
                activity.setIntent(intent);
                try {
                    // for 4.1+
                    ReflectUtil.setField(ContextThemeWrapper.class, activity, "mResources", plugin.getResources());
                } catch (Exception ignored) {
                    // ignored.
                }
                return activity;
            }
        }
        return mBase.newActivity(cl, className, intent);
    }
```
* 将Resource，Context等替换成插件中相应对象。

```java
    @Override
    public void callActivityOnCreate(Activity activity, Bundle icicle) {
        final Intent intent = activity.getIntent();
        if (PluginUtil.isIntentFromPlugin(intent)) {
            Context base = activity.getBaseContext();
            try {
                LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);
                ReflectUtil.setField(base.getClass(), base, "mResources", plugin.getResources());
                ReflectUtil.setField(ContextWrapper.class, activity, "mBase", plugin.getPluginContext());
                ReflectUtil.setField(Activity.class, activity, "mApplication", plugin.getApplication());
                ReflectUtil.setFieldNoException(ContextThemeWrapper.class, activity, "mBase", plugin.getPluginContext());

                // set screenOrientation
                ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent));
                if (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
                    activity.setRequestedOrientation(activityInfo.screenOrientation);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
        mBase.callActivityOnCreate(activity, icicle);
    }
```

## 插件Apk的加载和解析
加载apk的过程通常是通过插件apk文件解析出PackageInfo，ApplicaiontInfo，ComponentInfo（ActivityInfo，ServiceInfo等）。生成插件的Resource，插件的Classloader，插件的Context等。
### 解析apk相关信息
VirtualApk使用的方案是通过系统的PackageParse得到Package，需要考虑版本兼容性和反射相关方法。然后再创建PackageInfo，使用Package中相关信息初始化后使用。

```java
this.mPackage = PackageParserCompat.parsePackage(context, apk, PackageParser.PARSE_MUST_BE_APK);
this.mPackage.applicationInfo.metaData = this.mPackage.mAppMetaData;
this.mPackageInfo = new PackageInfo();
this.mPackageInfo.applicationInfo = this.mPackage.applicationInfo;
this.mPackageInfo.applicationInfo.sourceDir = apk.getAbsolutePath();
// Cache activities
Map<ComponentName, ActivityInfo> activityInfos = new HashMap<ComponentName, ActivityInfo>();
for (PackageParser.Activity activity : this.mPackage.activities) {            
    activityInfos.put(activity.getComponentName(), activity.info);
}
this.mActivityInfos = Collections.unmodifiableMap(activityInfos);
this.mPackageInfo.activities = activityInfos.values().toArray(new ActivityInfo[activityInfos.size()]);
。。。

    public static final PackageParser.Package parsePackage(final Context context, final File apk, final int flags) throws PackageParser.PackageParserException {
        if (Build.VERSION.SDK_INT >= 24) {
            return PackageParserV24.parsePackage(context, apk, flags);
        } else if (Build.VERSION.SDK_INT >= 21) {
            return PackageParserLollipop.parsePackage(context, apk, flags);
        } else {
            return PackageParserLegacy.parsePackage(context, apk, flags);
        }
    }

    private static final class PackageParserV24 {

        static final PackageParser.Package parsePackage(Context context, File apk, int flags) throws PackageParser.PackageParserException {
            PackageParser parser = new PackageParser();
            PackageParser.Package pkg = parser.parsePackage(apk, flags);
            ReflectUtil.invokeNoException(PackageParser.class, null, "collectCertificates",
                    new Class[]{PackageParser.Package.class, int.class}, pkg, flags);
            return pkg;
        }
    }
```

实际上应该可以通过PackageManager直接得到的吧？Replugin也是这样做的，并且跟踪PackageManager解析apk的过程也是在内部通过PackageParse解析的。

```java
PackageManager pm = mContext.getPackageManager();
mPackageInfo = pm.getPackageArchiveInfo(mPath, PackageManager.GET_ACTIVITIES | PackageManager.GET_META_DATA);
mPackageInfo.applicationInfo.sourceDir = mPath;
...

    public PackageInfo getPackageArchiveInfo(String archiveFilePath, @PackageInfoFlags int flags) {
        final PackageParser parser = new PackageParser();
        final File apkFile = new File(archiveFilePath);
        try {
            if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
                // Caller expressed an explicit opinion about what encryption
                // aware/unaware components they want to see, so fall through and
                // give them what they want
            } else {
                // Caller expressed no opinion, so match everything
                flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
            }

            PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
            if ((flags & GET_SIGNATURES) != 0) {
                PackageParser.collectCertificates(pkg, 0);
            }
            PackageUserState state = new PackageUserState();
            return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
        } catch (PackageParserException e) {
            return null;
        }
    }
```
### 生成插件Resource
VirtualApk支持单独使用插件资源和宿主插件资源合并使用。宿主插件资源合并使用hook替换宿主的Resouce已经修改打包插件，我们以后再看。单独使用插件资源和我们之前使用的插件资源使用类似。

```java
    @WorkerThread
    private static Resources createResources(Context context, File apk) {
        if (Constants.COMBINE_RESOURCES) {
            Resources resources = ResourcesManager.createResources(context, apk.getAbsolutePath());
            ResourcesManager.hookResources(context, resources);
            return resources;
        } else {
            Resources hostResources = context.getResources();
            AssetManager assetManager = createAssetManager(context, apk);
            return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
        }
    }
    
    private static AssetManager createAssetManager(Context context, File apk) {
        try {
            AssetManager am = AssetManager.class.newInstance();
            ReflectUtil.invoke(AssetManager.class, am, "addAssetPath", apk.getAbsolutePath());
            return am;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
```
上面的hook过程其实也是参照了系统加载生成Resource的过程。

```java
public Resources getTopLevelResources(String resDir, String[] splitResDirs,
    String[] overlayDirs, String[] libDirs, int displayId,
    Configuration overrideConfiguration, CompatibilityInfo compatInfo, IBinder token) {
final float scale = compatInfo.applicationScale;
ResourcesKey key = new ResourcesKey(resDir, displayId, overrideConfiguration, scale, token);
Resources r;
synchronized (this) {
//判断是否加载过该资源
    WeakReference<Resources> wr = mActiveResources.get(key);
    r = wr != null ? wr.get() : null;
    if (r != null && r.getAssets().isUpToDate()) {
    //已加载过，直接返回
        return r;
    }
}
//没有加载过，构建AssetManager对象
AssetManager assets = new AssetManager();
   //将APK路径添加到AssetManager的资源路径中
if (resDir != null) {
    if (assets.addAssetPath(resDir) == 0) {
        return null;
    }
}
//屏幕分辨率
DisplayMetrics dm = getDisplayMetricsLocked(displayId);
//设备配置
Configuration config;
//创建Resources
r = new Resources(assets, dm, config, compatInfo, token);
if (false) {
    Slog.i(TAG, "Created app resources " + resDir + " " + r + ": "
            + r.getConfiguration() + " appScale="
            + r.getCompatibilityInfo().applicationScale);
}
synchronized (this) {
    //缓存资源 
    mActiveResources.put(key, new WeakReference<Resources>(r));
    return r;
}
}
```

除了类似于上面创建Resource的过程，先反射创建AssertManager，在反射调用其方法addAssertPath。然后再使用这个AssertManager创建Resource。
系统还提供了一个getResourcesForApplication的api，我们只要有ApplicationInfo就可以得到对应的Apk中的resource，不用反射和hook。Replugin使用的就是这个方案。

```java
PackageManager pm = mContext.getPackageManager();
mPkgResources = pm.getResourcesForApplication(mPackageInfo.applicationInfo);

// ApplicationPackageManager
@Override
public Resources getResourcesForApplication(@NonNull ApplicationInfo app){

    //...
    //省略了部分源码
    final Resources r = mContext.mMainThread.getTopLevelResources(
            sameUid ? app.sourceDir : app.publicSourceDir,
            sameUid ? app.splitSourceDirs : app.splitPublicSourceDirs,
            app.resourceDirs, app.sharedLibraryFiles, Display.DEFAULT_DISPLAY,
            null, mContext.mPackageInfo);
    if (r != null) {
        return r;
    }
   
}
```

### 创建插件Classloader
创建Classloader方案都差不多，因为只用DexClassloader才能加载未安装的apk中的dex。

```java
    private static ClassLoader createClassLoader(Context context, File apk, File libsDir, ClassLoader parent) {
        File dexOutputDir = context.getDir(Constants.OPTIMIZE_DIR, Context.MODE_PRIVATE);
        String dexOutputPath = dexOutputDir.getAbsolutePath();
        DexClassLoader loader = new DexClassLoader(apk.getAbsolutePath(), dexOutputPath, libsDir.getAbsolutePath(), parent);

        if (Constants.COMBINE_CLASSLOADER) {
            try {
                DexUtil.insertDex(loader);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        return loader;
    }
```
### 创建插件使用的Context
创建给插件使用的Context并修改为使用插件中相关资源。

```java
    @Override
    public Resources getResources() {
        return this.mPlugin.getResources();
    }

    @Override
    public AssetManager getAssets() {
        return this.mPlugin.getAssets();
    }

    @Override
    public Resources.Theme getTheme() {
        return this.mPlugin.getTheme();
    }
    。。。
```
这样在需要的时候就可以使用这些插件中信息。比如在Instrumentation中创建插件Activity时：

```java
    @Override
    public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        try {
            cl.loadClass(className);
        } catch (ClassNotFoundException e) {
            LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);
            String targetClassName = PluginUtil.getTargetActivity(intent);

            Log.i(TAG, String.format("newActivity[%s : %s]", className, targetClassName));

            if (targetClassName != null) {
                Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);
                activity.setIntent(intent);

                try {
                    // for 4.1+
                    ReflectUtil.setField(ContextThemeWrapper.class, activity, "mResources", plugin.getResources());
                } catch (Exception ignored) {
                    // ignored.
                }

                return activity;
            }
        }

        return mBase.newActivity(cl, className, intent);
    }
```
在Activity创建后替换使用插件自己的Resouce资源等。

```java
    @Override
    public void callActivityOnCreate(Activity activity, Bundle icicle) {
        final Intent intent = activity.getIntent();
        if (PluginUtil.isIntentFromPlugin(intent)) {
            Context base = activity.getBaseContext();
            try {
                LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);
                ReflectUtil.setField(base.getClass(), base, "mResources", plugin.getResources());
                ReflectUtil.setField(ContextWrapper.class, activity, "mBase", plugin.getPluginContext());
                ReflectUtil.setField(Activity.class, activity, "mApplication", plugin.getApplication());
                ReflectUtil.setFieldNoException(ContextThemeWrapper.class, activity, "mBase", plugin.getPluginContext());

                // set screenOrientation
                ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent));
                if (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
                    activity.setRequestedOrientation(activityInfo.screenOrientation);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }

        }

        mBase.callActivityOnCreate(activity, icicle);
    }
```

## 其他
VirtualApk工程源码地址:https://github.com/didi/VirtualAPK
使用VirtualApk原理实践的工程地址：https://github.com/liyonganStudy/plugin-va-master
### 关于Theme和AppCompatActivity
当插件Activity继承自AppCompatActivity时，因为坑位activity是没有定义theme的，会报如下异常：

```java
java.lang.RuntimeException: Unable to start activity ComponentInfo{com.netease.clousmusic.pluginvademo/com.netease.clousmusic.pluginengin.A$1}: 
java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.
```

```java
// ActivityThread
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
                activity.mStartedActivity = false;
                int theme = r.activityInfo.getThemeResource();
                if (theme != 0) {
                    activity.setTheme(theme);
                }
                activity.mCalled = false;
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
```
我们可以在mInstrumentation.callActivityOnCreate在设置theme。

```java
public void callActivityOnCreate(Activity activity, Bundle icicle) {
    ...
    activity.setTheme(plugin.getThemeId());
    ...
}
```
这时会报如下错误：

```
java.lang.RuntimeException: Unable to start activity ComponentInfo{com.netease.clousmusic.pluginvademo/com.netease.clousmusic.pluginengin.A$1}: 

android.content.res.Resources$NotFoundException: Resource ID #0x7f030017

at android.support.v7.app.AppCompatDelegateImplV9.createSubDecor(AppCompatDelegateImplV9.java:
at android.support.v7.app.AppCompatDelegateImplV9.ensureSubDecor(AppCompatDelegateImplV9.java:
at android.support.v7.app.AppCompatDelegateImplV9.setContentView(AppCompatDelegateImplV9.java:
at android.support.v7.app.AppCompatActivity.setContentView(AppCompatActivity.java:140)
```
上面我们已经在callActivityOnCreate反射将Resouce，context等替换为插件中相应的Resource了，为什么还是会报资源找不到呢？跟踪源码发现是support包中的控件和相关资源找不到。
同时在inflate这些类时也没有调用插件Context中的getSystemService获取LayoutInflate。
推测这些view的创建还是使用的宿主的Resouce和LayoutInflate，所以存在资源找不到问题。

```java
    @Override
    public Object getSystemService(String name) {
        // intercept CLIPBOARD_SERVICE,NOTIFICATION_SERVICE
        if (name.equals(Context.CLIPBOARD_SERVICE)) {
            return getHostContext().getSystemService(name);
        } else if (name.equals(Context.NOTIFICATION_SERVICE)) {
            return getHostContext().getSystemService(name);
        } else if (LAYOUT_INFLATER_SERVICE.equals(name)) {
            if (mInflater == null) {
                LayoutInflater inflater = (LayoutInflater) super.getSystemService(name);
                // 新建一个，设置其工厂
                mInflater = inflater.cloneInContext(this);
                mInflater.setFactory(mFactory);
                // 再新建一个，后续可再次设置工厂
                mInflater = mInflater.cloneInContext(this);
            }
            return mInflater;
        }

        return super.getSystemService(name);
    }
```

在**mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);**上面我们发现会先调用**activity.attach**

```java
    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

        mWindow = new PhoneWindow(this, window);
        mWindow.setWindowControllerCallback(this);
        mWindow.setCallback(this);
        mWindow.setOnWindowDismissedCallback(this);
        mWindow.getLayoutInflater().setPrivateFactory(this);
```
我们发现在我们发射替换Resouce之前的Activity.attach方法中就已经发生了**mWindow.getLayoutInflater()**创建上面的window层级的View。
所以我们应该在activity.attachBaseContext时就应该替换使用插件的Context和Resouce等对象。
这也是为什么VirtualApk没有支持AppCompatActivity的原因。这就导致插件工程也需要做些改变在attachBaseContext时使用插件对应的Context。

```java
    @Override
    protected void attachBaseContext(Context newBase) {
        if (mBase != null) {
            super.attachBaseContext(mBase);
        } else {
            super.attachBaseContext(newBase);
        }
    }
```

## 参考资料
[滴滴插件化方案 VirtualApk 源码解析](http://blog.csdn.net/lmj623565791/article/details/75000580)



